#!/usr/bin/perl
use strict;
use warnings;

=comment

there may be multiple prior clues for a word
if so, offer a way to see them - cycle around them.
if this is REedit and there is a clue for the
current date offer that first.
otherwise offer them in date order - with community
puzzles coming first.

=cut

# a poor man's database
use DB_File;
my %puzzle;
tie %puzzle, 'DB_File', 'nyt_puzzles.dbm';

use BeeUtil qw/
    table
    Tr
    td
/;

use CGI;
use CGI::Carp qw/
    fatalsToBrowser
    warningsToBrowser
/;
my $q = CGI->new();
print $q->header();
my $cgi = 'http://logicalpoetry.com/cgi-bin';

my $date = $q->param('date');
my $puzzle = $puzzle{$date};
$puzzle =~ s{\A [^|]* [|]\ s* }{}xms;
my @words = $puzzle =~ m{([a-z]+)}xmsg;
my $show_date = date($date)->format("%B %e, %Y");

my @found = split ' ', $q->param('found');
my %is_found = map { $_ => 1 } @found;

my $nnf = @words - @found;
my $nnf_disp = '';
if ($nnf) {
    if ($nnf == 1) {
        $nnf_disp = "As you know, there is 1 word that has not yet been found.  This word will be hidden.<p>";
    }
    else {
        $nnf_disp = "As you know, there are $nnf words that have not yet been found.  These words will be hidden.<p>";
    }
}

use Date::Simple qw/
    date
/;
use Bee_DBH qw/
    $dbh
    get_person
/;

my ($ip_id, $person_id, $name, $location) = get_person();
my %clue_for;
my $got_clues = 0;

if ($person_id) {
    # we've seen this person before
    # they have either made a puzzle or added clues
    # for some date (maybe not the current one).
    #
    # first, see if there are EXISTING clues for this date
    # from this person
    #
    my $sth_clue = $dbh->prepare(<<'EOS');

        SELECT word, clue
          FROM bee_clue
         WHERE person_id = ?
           AND date = ?

EOS
    $sth_clue->execute($person_id, $date);
    while (my ($word, $clue) = $sth_clue->fetchrow_array()) {
        $clue_for{$word} = $clue;
        $got_clues = 1;
    }
}

# See if we have clues for the current set of words
# *from this person* for *other* dates.
# Eliminate duplicate clues.
#
if (@found) {
    my $quoted_words = join ', ',
                       map {
                           "'$_'"
                       }
                       @found;
    my $sth_clue = $dbh->prepare(<<"EOS");

        SELECT distinct word, clue
          FROM bee_clue
         WHERE person_id = ?
           AND word in ($quoted_words)
           AND date != ?
      ORDER BY date desc

EOS
    $sth_clue->execute($person_id, $date);
    while (my ($word, $clue) = $sth_clue->fetchrow_array()) {
        if (exists $clue_for{$word}) {
            # if needed, convert the value into an array ref
            if (ref $clue_for{$word} eq 'ARRAY') {
                push @{$clue_for{$word}}, $clue;
            }
            else {
                my $clue1 = $clue_for{$word};
                $clue_for{$word} = [ $clue1, $clue ];
            }
        }
        else {
            $clue_for{$word} = $clue;
        }
    }
}

# for the words that have multiple prior clues
# we craft a JSON string.
my %clues_for_json;
for my $w (@words) {
    if (ref $clue_for{$w} eq 'ARRAY') {
        $clues_for_json{$w} = {
            clues => $clue_for{$w},
            cur   => 0,
        };
    }
}
use JSON::PP qw/
    encode_json
/;
my $json = encode_json(\%clues_for_json);

my $prior_clues = $got_clues? "<p>You have given clues for some of the words before.": '';
if (%clues_for_json) {
    $prior_clues .= "If there is more than one clue for a word you can cycle through them by clicking the <img height=25 src=/nytbee/cycle.jpg> icon.";
}

print <<"EOH";
<html>
<head>
<link rel='stylesheet' type='text/css' href='/nytbee/cgi_style.css'/>
<script>
var newwin;
function popup_define(word, height, width) {
    newwin = window.open(
        "$cgi/nytbee_define/" + word, 'define',
        'height=' + height + ',width=' + width +', scrollbars'
    );
    newwin.moveTo(800, 0);
    var el = document.getElementById(word + '_clue').focus();
}
var clues_for = $json;
function cycle(w) {
    clues_for[w].cur = (clues_for[w].cur + 1) % clues_for[w].clues.length;
    document.getElementById(w + '_clue').value
        = clues_for[w].clues[ clues_for[w].cur ];
}
</script>
</head>
<body>
<h2>Clues for the NYT Puzzle<br>on $show_date</h2>
<form name=form action=nytbee_mkclues2>
<input type=hidden name=date value='$date'>
<p>
$nnf_disp
You do not have to give clues for all of the words.
You can click on the words to get a dictionary definition.
You may, instead, wish to give clues that are more
ambiguous, clever, wordplay &#128522; - like clues for a crossword puzzle.
$prior_clues
<p>
<table cellpadding=3>
<tr><td>Your Name</td><td><input name=name size=30 value='$name'></td></tr>
<tr><td>Your Location</td><td><input name=location size=30 value='$location'></td></tr>
<tr><td colspan=2>&nbsp;</td></tr>
EOH
for my $w (@words) {
    my $uw = ucfirst $w;
    my ($word_td, $clue_td, $cycle_td);
    if ($is_found{$w}) {
        my $clue;
        if (exists $clue_for{$w}) {
            if (ref $clue_for{$w}) {
                # there is more than one prior clue
                $clue = $clue_for{$w}->[0];
                $cycle_td = td(qq!<img class=cursor onclick='cycle("$w");' src='/nytbee/cycle.jpg'>!);
            }
            else {
                $clue = $clue_for{$w};
            }
        }
        else {
            $clue = '';
        }
        $word_td = td(qq!<a href="javascript:popup_define('$w',300,500)">$uw</a>!);
        $clue_td = td("<input type=text size=30 name=${w}_clue id=${w}_clue"
                 . qq! value="$clue">!)
    }
    else {
        $word_td = td({ class => 'word_td'}, '&nbsp;');
        $clue_td = td('&nbsp;');
    }
    print Tr($word_td, $clue_td, $cycle_td), "\n";
}
print Tr(td('&nbsp'), td({ style => 'text-align: left;' }, "<button type=submit>Submit</button>")), "\n";
print <<"EOH";
</table>
</body>
</html>
<script>document.form.name.focus()</script>
EOH
