#!/usr/bin/perl
use strict;
use warnings;
use CGI;
my $q = CGI->new();
print $q->header();

use CGI::Carp qw/
    warningsToBrowser
    fatalsToBrowser
/;

use BeeUtil qw/
    uniq_chars
    error
    table
    Tr
    td
/;
use Bee_DBH qw/
    $dbh
    get_person
    get_clues
/;

my $n = $q->param('CPn');
my $cp_href = do "community_puzzles/$n.txt";
my $ip_id = $cp_href->{ip_id};
my $person_id = $cp_href->{person_id};

my $seven = $cp_href->{seven};
my $center = $cp_href->{center};
my @other_words = split ' ', $q->param('other_words');
my $regex = qr{[^$seven]}xms;

# do these extra words 'qualify'?
my @not_okay;
for my $w (@other_words) {
    if (length $w < 4
        || $w =~ $regex
        || index($w, $center) < 0
    ) {
        push @not_okay, $w;
    }
}
if (@not_okay) {
    error "These words do not qualify:<ul>"
        . join('', map { "$_<br>\n" } @not_okay)
        . "</ul>\n";
}
my @ok_words = sort $q->param('ok'), @other_words;
# is there at least one pangram?
my @pangrams;
for my $w (@ok_words) {
    if (uniq_chars($w) == 7) {
        push @pangrams, $w;
    }
}
if (! @pangrams) {
    error "In the many words there is no pangram! :(";
}

my ($href_prior_clues_for, $json)
    = get_clues($person_id, \@ok_words, $cp_href->{clues});

=comment

# did the person give a clue for any of the @ok_words before?
# offer them..
# there may be more than one - in this case have a way
# to cycle through the clues - in date order.
# with community puzzles coming first.
# dup code with nytbee_clues???
# can we reuse?
#
my %prior_clues_for;
my $got_clues = 0;
if ($person_id) {
    my $words = join ', ',
                map {
                    "'$_'"
                }
                @ok_words;
    my $sth_clue = $dbh->prepare(<<"EOS");

        SELECT distinct word, clue
          FROM bee_clue
         WHERE person_id = $person_id
           AND word IN ($words)
      ORDER BY date desc;

EOS
    # we are editing an existing community puzzle 
    # the clues from before will very likely be the first
    # to come back from the database.  is it assured?
    # we did sort by date desc.   if a later puzzle (CP or NYT)
    # word and clue matched this puzzle ... hmmm.
    #
    # TODO
    # we should initialize %prior_clues_for
    # with the clues in $href->{clues} but only
    # for the words that remain ...
    # and then do not duplicate when getting clues from the DB...
    #
    $sth_clue->execute();
    while (my ($word, $clue) = $sth_clue->fetchrow_array()) {
        $got_clues = 1;
        if (exists $prior_clues_for{$word}) {
            if (ref $prior_clues_for{$word} eq 'ARRAY') {
                push @{$prior_clues_for{$word}}, $clue;
            }
            else {
                my $clue1 = $prior_clues_for{$word};
                $prior_clues_for{$word} = [ $clue1, $clue ];
            }
        }
        else {
            $prior_clues_for{$word} = $clue;
        }
    }
}

# for the words that have multiple prior clues
# we craft a JSON string.
my %clues_for_json;
for my $w (@ok_words) {
    if (ref $prior_clues_for{$w} eq 'ARRAY') {
        $clues_for_json{$w} = {
            clues => $prior_clues_for{$w},
            cur   => 0,
        };
    }
}
use JSON::PP qw/
    encode_json
/;
my $json = encode_json(\%clues_for_json);

=cut

my $prior_clues = '';
if ($json) {
    $prior_clues .= " If there is more than one clue for a word you can cycle through them by clicking the <img height=25 src=/nytbee/cycle.jpg> icon.<p>";
}

my $cgi = 'http://logicalpoetry.com/cgi-bin';

print <<"EOH";
<html>
<head>
<link rel='stylesheet' type='text/css' href='http://logicalpoetry.com/nytbee/cgi_style.css'/>
<script>
var newwin;
function popup_define(word, height, width) {
    document.getElementById(word + '_clue').focus();
    newwin = window.open(
        'http://logicalpoetry.com/cgi-bin/nytbee_define/' + word, 'define',
        'height=' + height + ',width=' + width +', scrollbars'
    );
    newwin.moveTo(800, 0);
}
var clues_for = $json;
function cycle(w) {
    clues_for[w].cur = (clues_for[w].cur + 1) % clues_for[w].clues.length;
    document.getElementById(w + '_clue').value
        = clues_for[w].clues[ clues_for[w].cur ];
}
</script>
</head>
<body>
<h1>Editing CP$n<br> <span class=step_name>Clues</span></h1>
Optionally, provide clues for each word.
$prior_clues
You can click on the words to get a dictionary definition.
You may, instead, wish to give clues that are ambiguous, clever, wordplay &#128522; - like clues for a crossword.
<p>
<form name=form action=/cgi-bin/edit_cp_final method=POST>
<input type=hidden name=CPn value='$n'>
<input type=hidden name=seven value='$seven'>
<input type=hidden name=center value='$center'>
<input type=hidden name=words value='@ok_words'>
<input type=hidden name=pangrams value='@pangrams'>
EOH
my @rows;
for my $w (@ok_words) {
    my $uw = ucfirst $w;
    my ($word_td, $clue_td, $cycle_td);
    my $clue;
    if (exists $href_prior_clues_for->{$w}) {
        if (ref $href_prior_clues_for->{$w}) {
            # there is more than one prior clue
            $clue = $href_prior_clues_for->{$w}[0];
            $cycle_td = td(qq!<img class=cursor onclick='cycle("$w");' src='/nytbee/cycle.jpg'>!);
        }
        else {
            $clue = $href_prior_clues_for->{$w};
        }
    }
    else {
        $clue = '';
    }
    $word_td = td(qq!<a href="javascript:popup_define('$w',300,500)">$uw</a>!);
    $clue_td = td("<input type=text size=40 name=${w}_clue id=${w}_clue"
             . qq! value="$clue">!);
    push @rows, Tr($word_td, $clue_td, $cycle_td);
}
print table(@rows);
print <<"EOH";
<p>
<button class=submit type=submit>Submit</button>
</body>
</html>
<script>document.form.$ok_words[0]_clue.focus();</script>
EOH

=comment

The usual NYT Spelling Bee puzzle includes
ALL normal qualifying words.   If there are clues for
each word then the maker of the puzzle need not include ALL.
Instead, it becomes a kind of crossword puzzle with clues where
you know that the answer words are composed of the seven letters.
You're not trying to 'find' all words that can be made.

=cut
